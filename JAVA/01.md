<details>
  <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

### 답변

- 장점
  - 운영체제에 독립적이다. 
    - JVM에서 동작하기 때문에, 특정 운영체제에 종속되지 않는다.
  - 객체지향 언어이다. 
    - 객체지향적으로 프로그래밍 하기 위해 여러 언어적 지원을 하고있다. (캡슐화, 상속, 추상화, 다형성 등)
    - 객체지향 패러다임의 특성상 비교적 이해하고 배우기 쉽다.
- 단점
  - 비교적 속도가 느리다. 
    - 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다. 
    - 그러나 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다.

</details>
<details>
  <summary><b>java와 c/c++의 차이점</b></summary>

### 답변
- java와 c/c++의 가장 큰 차이점은 실행 환경이다. 
- java에서의 개발: 컴파일 혹은 컴파일 + jar압축 
- 자바는 링크 과정이 없이 컴파일러가 바로 바이트 코드를 생성 
- c/c++에서의 개발: 컴파일 + 링크

</details>

---
<details>
  <summary><b>객체지향이란 무엇인지 설명해주세요.</b></summary>

### 답변
- 객체 
  - 현실 세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합
- 객체지향 프로그래밍
  - 실세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 나타낸다.
  - 객체를 추출하고 객체들의 관계를 결정하고 이들의 상호 작용에 필요한 함수(메서드)와 변수(필드)를 설계 및 구현하다.
  - 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍하는 것
  - 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

- 절차지향 프로그래밍 <-> 객체지향 프로그래밍
  - 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법 
  - 목적을 달성하기 위한 일의 흐름에 중점을 둔다.

</details>

<details>
  <summary><b>객체지향 프로그래밍의 장단점에 대해 설명해주세요.</b></summary>

### 답변
- 객체지향프로그래밍
  - 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
- 장점 
  - 코드 재사용 용이 
  - 유지보수 용이 
  - 대형 프로젝트에 적합
- 단점 
  - 처리 속도 느림 
  - 설계가 어려움

</details>

<details>
  <summary><b>객체지향 프로그래밍의 특징에 대해 설명해주세요.</b></summary>

### 답변
- 캡상추다
- 캡슐화 
  - 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것 
  - 목적 
    - 데이터 보호: 외부로부터 클래스에 정의된 속성과 기능들을 보호 
    - 데이터 은닉: 내부의 동작을 감추고 외부에는 필요한 부분만 노출 (각 객체 고유의 독립성과 책임 영역을 안전하게 지킬 수 있다.)
  - 접근제어자와 getter/setter 를 통해 구현
- 상속 
  - 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법요소 
  - 코드의 재사용을 통해 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근할 수 있다. 
  - 상속과 구현 
    - 상속: 상위 클래스의 속성과 기능들을 하위 클래스에서 그대로 받아 사용하거나 오버라이딩을 통해 선택적으로 재정의해서 사용 
    - 구현: 반드시 인터페이스에 정의된 추상 메서드의 내용이 하위 클래스에서 정의
- 추상화 
  - 객체의 공통적인 속성과 기능을 추출하여 정의하는 것 
  - 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것
  - 추상클래스와 인테페이스로 구현
- 다형성
  - 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질 
  - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
  - 메서드 오버라이딩과 오버로딩을 통해 구현 
  - 가능한 것 예시 
    - 여러 종류의 객체를 배열로 다룰 수 있다.
    - 하나의 타입만으로 여러 가지 타입의 객체를 참조할 수 있다.

</details>

<details>
  <summary><b>객체지향 프로그래밍의 5대 원칙에 대해 설명해주세요.</b></summary>

### 답변
- "SOLID" 원칙

- S: 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 객체는 단 하나의 책임만 가져야 한다. 
- O: 개방-폐쇄 원칙(OCP, Open Closed Principle)
  - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. 
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다. 
- I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다. 
- D: 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.

</details>


---
<details>
  <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary>

### 답변
- 자바는 Call by Value 를 따릅니다. 기본 자료형의 경우 `해당 값이 복사`되어 전달되고, 참조 자료형의 경우 `힙 메모리의 참조값이 복사`되어 전달됩니다.

- 자바에서 파라미터는 항상 `값`으로 전달됩니다. (파라미터의 복사본이 메서드에 전달)
- `기본 자료형`의 경우 `값의 복사본`이 전달됩니다.
- `참조 자료형`의 경우 힙 메모리의 `주소값이 복사`되어 전달됩니다.
  - 아래 예시의 경우 User 의 메모리가 복사되어 전달된다. b 의 경우 새로운 주소를 할당하는데 메서드가 종료되면 원본 b 에는 반영되지 않는다.
  ```java
  class User {
      public int age;
  
      public User(int age) {
          this.age = age;
      }
  }
  
  public class ReferenceTypeTest {
  
      void test() {
          User a = new User(10);
          User b = new User(20);
  			  
          System.out.println(a); // age: 10
          System.out.println(b); // age: 20
          modify(a, b);
  
          System.out.println(a); // age: 11 
          System.out.println(b); // age: 20
      }
  
      private void modify(User a, User b) {
          a.age++;
  
          b = new User(30);
          b.age++;
      }
  }
  ```
  
</details>

---
<details>
  <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

### 답변
- 자바의 데이터 타입은 기본 데이터 타입과 참조 타입으로 나뉩니다. 
- 기본 데이터 타입으로는 byte, short, int, long, float, double, boolean, char 가 있으며 Stack 영역에 저장됩니다. 
- 참조 타입은 기본형은 제외한 모든 타입이며, Heap 영역에 저장됩니다.

- `기본 데이터 타입(Primitive Data Type)`
  - 정수형 : byte, short, int, long
  - 실수형 : float, double
  - 논리형 : boolean(ture/false)
  - 문자형 : char
  - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.

- `참조 타입(Reference Data Type)`
  - 참조 타입 종류: class, array, interface, Enumeration
  - 기본형을 제외하고는 모두 참조형
  - new 키워드를 이용하여 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이다.
  - String, StringBuffer, List, 개인이 만든 클래스 등
  - String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
  - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
  - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
  - 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)
</details>


<details>
  <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

### 답변
- Wrapper 클래스는 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스입니다. 
- 기본 타입의 데이터를 Wrapper 클래스의 값으로 변환하면 Boxing, 반대의 경우를 Unboxing이라고 합니다. 
- 프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있다. 
- 예를 들어, 메소드의 인수로 객체 타입만이 요구되면 기본 타입의 데이터를 그대로 사용할 수는 없다. 이때 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 한다.

- Wrapper Class
  - 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스
  - java.lang 패키지에 존재

| 기본 타입     | 래퍼 클래스      |
|-----------|-------------|
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

### 박싱(Boxing), 언박싱(Unboxing)
- Boxing
  - 기본 타입의 데이터를 Wapper 클래스의 인스턴스로 변환하는 과정
- Unboxing
  - Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 꺼내는 과정

### 오토 박싱(AutoBoxing)과 오토 언박싱(AutoUnBoxing)
- JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해 준다. 
- 이렇게 자동화된 박싱과 언박싱을 오토 박싱(AutoBoxing)과 오토 언박싱(AutoUnBoxing)이라고 부른다.

```java
Integer num = new Integer(17); // 박싱
int n = num.intValue();        // 언박싱
System.out.println(n); // 출력 값: 17


Character ch = 'X'; // Character ch = new Character('X'); : 오토박싱
char c = ch;        // char c = ch.charValue();           : 오토언박싱
System.out.println(c); // 출력 값: X
```
- 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 Character 인스턴스를 생성할 수 있다. 
- 반대로 charValue() 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있다.

</details>

---
<details>
  <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>static 키워드에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary>

### 답변


</details>
<details>
  <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary>

### 답변


</details>
<details>
  <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary>

### 답변


</details>
<details>
  <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary>

### 답변


</details>

<details>
  <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>제네릭에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>자바의 직렬화는 언제, 어디서 사용되나요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>Thread Local에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>자바 8에 추가된 기능들에 대해 간단히 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Stream에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>Stream과 반복문 for문의 성능차이가 있을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Lambda에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>익명 클래스(Anonymous Inner Class)와 Lambda의 차이점을 알고계신가요?</b></summary>

### 답변


</details>
<details>
  <summary><b>람다식에서, 외부 변수를 사용할 때 final 키워드를 붙여서 사용하는 이유가 무엇일까요? final을 안 붙여도 되지 않을까요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Optional에 대해 설명해주세요. Optional을 사용하면 무슨 이점이 있을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>Optional을 사용하면서 주의해야할 점이 있을까요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Object 클래스의 equals()와 hashcode()는 무슨 역할을 하나요?</b></summary>

### 답변


</details>
<details>
  <summary><b>equals()와 hashcode()는 언제 재정의해야할까요? 또, 왜 같이 오버라이딩 하는게 좋을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>서로 다른 인스턴스가 같은 hashcode값을 가질 수 있을까요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>String 클래스는 final로 선언되어있습니다. 왜 그런걸까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>String을 new 또는 "" 로 생성했을 때의 차이점을 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>String, StringBuilder, StringBuffer 를 각각 비교해주세요.</b></summary>

### 답변


</details>

---

<details>
  <summary><b>컬렉션 프레임워크에 대해 설명해주세요.</b></summary>

### 답변


</details>

---

<details>
  <summary><b>List 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>Array와 ArrayList는 어떤 차이점이 있을까요?</b></summary>

### 답변


</details>
<details>
  <summary><b>ArrayList는 내부적으로 어떻게 구현되어있나요?</b></summary>

### 답변


</details>
<details>
  <summary><b>ArrayList 와 LinkedList를 비교해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Map 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>HashTable에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>HashMap과 HashTable을 비교해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>HashMap과 ConcurrentHashMap은 어떤 차이가 있나요?</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Set 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>List와 Set을 비교해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>Java의 컴파일(실행) 과정을 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>JDK, JRE, JVM에 대해 설명해주세요.</b></summary>

### 답변


</details>
<details>
  <summary><b>JVM의 메모리 구조에 대해 설명해주세요.</b></summary>

### 답변


</details>

---
<details>
  <summary><b>클래스 로더</b></summary>

### 답변


</details>
<details>
  <summary><b>정적 바인딩, 동적 바인딩</b></summary>

### 답변


</details>
<details>
  <summary><b>가비지 컬렉터</b></summary>

### 답변


</details>
<details>
  <summary><b>java의 가비지 컬렉션 처리 방법</b></summary>

### 답변


</details>

---
<details>
  <summary><b>객체 지향 프로그래밍(캡상추다)</b></summary>

### 답변


</details>
<details>
  <summary><b>SOLID 원칙</b></summary>

### 답변


</details>
<details>
  <summary><b>객체 지향 프로그래밍 vs 절차 지향 프로그래밍</b></summary>

### 답변


</details>

---


